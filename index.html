<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rastreador GPS</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1500;
            position: relative;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 14px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Telemetry Bar */
        .telemetry-bar {
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            transition: all 0.3s;
            overflow: hidden;
            position: relative;
            z-index: 1400;
        }

        .telemetry-bar.collapsed {
            height: 50px;
        }

        .telemetry-bar.expanded {
            height: 140px;
        }

        .telemetry-toggle {
            position: absolute;
            right: 20px;
            top: 15px;
            cursor: pointer;
            font-size: 20px;
            transition: transform 0.3s;
        }

        .telemetry-bar.expanded .telemetry-toggle {
            transform: rotate(180deg);
        }

        .telemetry-content {
            padding: 10px 20px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .telemetry-item {
            text-align: center;
        }

        .telemetry-label {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .telemetry-value {
            font-size: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .telemetry-icon {
            font-size: 18px;
        }

        .telemetry-item.gsm .telemetry-value {
            color: #f093fb;
        }

        /* Map Container */
        .map-container {
            position: relative;
            transition: all 0.3s;
        }

        .map-container.with-telemetry-collapsed {
            height: calc(100vh - 70px - 50px);
        }

        .map-container.with-telemetry-expanded {
            height: calc(100vh - 70px - 140px);
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Bottom Sheet */
        .nodes-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #16213e;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s;
            z-index: 1300;
            max-height: 60vh;
        }

        .nodes-sheet.minimized {
            transform: translateY(calc(100% - 80px));
        }

        .nodes-sheet.expanded {
            transform: translateY(0);
        }

        .sheet-handle {
            width: 40px;
            height: 4px;
            background: #667eea;
            border-radius: 2px;
            margin: 10px auto;
            cursor: pointer;
        }

        .sheet-header {
            padding: 10px 20px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sheet-header h2 {
            font-size: 18px;
        }

        .node-count {
            background: #667eea;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
        }

        .nodes-list {
            padding: 15px;
            overflow-y: auto;
            max-height: calc(60vh - 80px);
        }

        /* Node Cards */
        .node-card {
            background: #0f3460;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s;
        }

        .node-card:hover {
            transform: translateX(5px);
        }

        .node-card.gsm {
            border-left-color: #f093fb;
        }

        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .node-name {
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .node-badge {
            background: #667eea;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .node-badge.gsm {
            background: #f093fb;
        }

        .node-info {
            font-size: 13px;
            line-height: 1.8;
            opacity: 0.9;
        }

        .node-info strong {
            color: #667eea;
        }

        /* Leaflet Custom Icons */
        .custom-icon {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: 700;
            font-size: 18px;
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #16213e;
            border-radius: 16px;
            padding: 24px;
            max-width: 90%;
            width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 16px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .modal-buttons .btn {
            flex: 1;
        }

        .loading {
            text-align: center;
            padding: 20px;
            opacity: 0.7;
        }

        /* Debug Panel */
        .debug-panel {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 90%;
            max-width: 400px;
            max-height: 300px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            z-index: 9999;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            overflow-y: auto;
            display: none;
        }

        .debug-panel.active {
            display: block;
        }

        .debug-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #667eea;
        }

        .debug-panel-title {
            color: #667eea;
            font-weight: bold;
            font-size: 12px;
        }

        .debug-panel-close {
            background: #667eea;
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }

        .debug-log {
            color: #0f0;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .debug-log-error {
            color: #f00;
        }

        .debug-log-warn {
            color: #ff0;
        }

        .debug-log-info {
            color: #0ff;
        }

        .debug-toggle-btn {
            position: fixed;
            bottom: 10px;
            right: 60px;
            background: #667eea;
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            z-index: 9998;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        /* Alert Notifications */
        .alert-notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 9999;
            animation: slideIn 0.3s ease-out;
            max-width: 350px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-icon {
            font-size: 32px;
        }

        .alert-content strong {
            display: block;
            margin-bottom: 5px;
            font-size: 16px;
        }

        .alert-content p {
            margin: 0;
            font-size: 13px;
            opacity: 0.9;
        }

        .alert-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
        }

        .alert-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Config Section */
        .config-section {
            margin: 15px 0;
        }

        .config-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .config-section input[type="number"] {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #0f3460;
            background: #0f3460;
            color: white;
            font-size: 14px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .toggle-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .alert-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .alert-history h4 {
            margin-bottom: 10px;
            font-size: 14px;
        }

        .alert-item {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .alert-item-time {
            color: #667eea;
            font-weight: 600;
        }

        /* Desktop Responsive */
        @media (min-width: 768px) {
            .nodes-sheet {
                right: auto;
                width: 380px;
                max-height: calc(100vh - 54px);
                border-radius: 0;
            }

            .nodes-sheet.minimized {
                transform: translateX(0);
            }

            .sheet-handle {
                display: none;
            }

            .debug-panel {
                bottom: 20px;
                right: 20px;
            }

            .debug-toggle-btn {
                bottom: 20px;
                right: 70px;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üõ∞Ô∏è Rastreador GPS</h1>
        <div class="header-buttons">
            <button class="btn" id="btnBluetooth" title="Conectar Bluetooth">üì°</button>
            <button class="btn" id="btnAlerts" title="Configurar Alertas">üîî</button>
            <button class="btn" id="btnReports" title="Generar Informe">üìä</button>
            <button class="btn" id="btnTogglePaths" title="Mostrar/Ocultar Trazas">üõ§Ô∏è</button>
            <button class="btn" id="btnClearPaths" title="Limpiar Trazas">üóëÔ∏è</button>
            <button class="btn" id="btnExport" title="Exportar Datos">üíæ</button>
            <button class="btn" id="btnRefresh" title="Actualizar">üîÑ</button>
        </div>
    </div>

    <div class="telemetry-bar collapsed" id="telemetryBar">
        <div class="telemetry-toggle" id="telemetryToggle"><span>‚ñº</span></div>
        <div class="telemetry-content">
            <div class="telemetry-item" id="telemetrySignal">
                <div class="telemetry-label">Se√±al</div>
                <div class="telemetry-value"><span class="telemetry-icon">üì∂</span><span id="signalType">--</span></div>
            </div>
            <div class="telemetry-item">
                <div class="telemetry-label">Potencia</div>
                <div class="telemetry-value"><span id="signalStrength">-- dBm</span></div>
            </div>
            <div class="telemetry-item">
                <div class="telemetry-label">Bater√≠a</div>
                <div class="telemetry-value"><span class="telemetry-icon">üîã</span><span id="batteryLevel">--%</span>
                </div>
            </div>
            <div class="telemetry-item">
                <div class="telemetry-label">Distancia</div>
                <div class="telemetry-value"><span class="telemetry-icon">üìè</span><span id="distance">-- m</span></div>
            </div>
        </div>
    </div>

    <div class="map-container with-telemetry-collapsed" id="mapContainer">
        <div id="map"></div>
    </div>

    <div class="nodes-sheet minimized" id="nodesSheet">
        <div class="sheet-handle" id="sheetHandle"></div>
        <div class="sheet-header">
            <h2>üì° Nodos Activos</h2>
            <div class="node-count" id="nodeCount">0</div>
        </div>
        <div class="nodes-list" id="nodesList">
            <div class="loading">Esperando conexi√≥n Bluetooth...</div>
        </div>
    </div>

    <!-- Debug Panel -->
    <button class="debug-toggle-btn" id="debugToggle" title="Mostrar/Ocultar Debug">üêõ</button>
    <div class="debug-panel" id="debugPanel">
        <div class="debug-panel-header">
            <div class="debug-panel-title">üì° DEBUG BLUETOOTH</div>
            <button class="debug-panel-close" id="debugClose">‚úï</button>
        </div>
        <div id="debugLog" class="debug-log"></div>
    </div>

    <!-- Modal Alertas -->
    <div class="modal" id="alertModal">
        <div class="modal-content">
            <div class="modal-title">‚öôÔ∏è Configuraci√≥n de Alertas</div>
            <div class="config-section">
                <label class="toggle-label">
                    <input type="checkbox" id="alertEnabled" checked>
                    <span>Activar alertas de movimiento</span>
                </label>
            </div>
            <div class="config-section">
                <label>Tiempo de quietud (minutos):</label>
                <input type="number" id="idleTime" value="5" min="1" max="120">
            </div>
            <div class="config-section">
                <label class="toggle-label">
                    <input type="checkbox" id="soundEnabled" checked>
                    <span>Activar sonido de alerta</span>
                </label>
            </div>
            <div class="alert-history">
                <h4>üìã Historial de Alertas</h4>
                <div id="alertHistoryList">
                    <p style="opacity: 0.6; font-size: 12px;">No hay alertas registradas</p>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn" id="btnSaveAlerts">Guardar</button>
                <button class="btn" id="btnCancelAlerts">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Modal Bluetooth -->
    <div class="modal" id="bluetoothModal">
        <div class="modal-content">
            <div class="modal-title">Conectar Dispositivo</div>
            <p id="bluetoothStatus">Presiona conectar para buscar dispositivos Bluetooth cercanos.</p>
            <div class="modal-buttons">
                <button class="btn" id="btnConnectBT">Conectar</button>
                <button class="btn" id="btnCancelBT">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Modal Exportar -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-title">Exportar Datos</div>
            <p>Selecciona el formato de exportaci√≥n:</p>
            <div class="modal-buttons">
                <button class="btn" id="btnExportCSV">CSV</button>
                <button class="btn" id="btnExportJSON">JSON</button>
                <button class="btn" id="btnCancelExport">Cancelar</button>
            </div>
        </div>
    </div>

    <script>
        // ========== CONFIGURACI√ìN ==========
        const CONFIG = {
            mapCenter: [-27.4514, -58.9867],
            mapZoom: 6,
            refreshInterval: 10000,
            apiEndpoint: '/json/nodes'
        };

        const MESH_SERVICE_UUID = '6ba1b218-15a8-461f-9fa8-5dcae273eafd';
        const JSON_NODES_UUID = 'e382570b-6072-4639-aa01-447551066804';

        // ========== ESTADO GLOBAL ==========
        let map = null;
        let markers = {};
        let userLocation = null;
        let bluetoothDevice = null;
        let db = null;
        let lastNodesData = [];
        let pathHistory = {}; // Almacena array de coordenadas por nodeId
        let pathLines = {};   // Almacena objetos Leaflet Polyline por nodeId
        let showPaths = true; // Toggle para mostrar/ocultar trazas

        // Sistema de Alertas
        let alertConfig = {
            enabled: true,
            idleTimeMinutes: 5,
            soundEnabled: true
        };
        let nodeStates = {}; // Estado de cada nodo: { lastPosition, lastMoveTime, isIdle }
        let alertHistory = []; // Historial de alertas disparadas

        // ========== INICIALIZACI√ìN ==========
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            initUI();
            initDataLogger();
            requestUserLocation();
        });

        function initMap() {
            map = L.map('map', { zoomControl: true, attributionControl: false }).setView(CONFIG.mapCenter, CONFIG.mapZoom);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
            L.control.zoom({ position: 'bottomright' }).addTo(map);
        }

        function initUI() {
            const telemetryBar = document.getElementById('telemetryBar');
            const telemetryToggle = document.getElementById('telemetryToggle');
            const mapContainer = document.getElementById('mapContainer');

            telemetryToggle.addEventListener('click', () => {
                telemetryBar.classList.toggle('collapsed');
                telemetryBar.classList.toggle('expanded');
                mapContainer.className = telemetryBar.classList.contains('expanded') ? 'map-container with-telemetry-expanded' : 'map-container with-telemetry-collapsed';
                setTimeout(() => map.invalidateSize(), 300);
            });

            const nodesSheet = document.getElementById('nodesSheet');
            const sheetHandle = document.getElementById('sheetHandle');
            sheetHandle.addEventListener('click', () => {
                nodesSheet.classList.toggle('minimized');
                nodesSheet.classList.toggle('expanded');
            });

            document.getElementById('btnBluetooth').addEventListener('click', openBluetoothModal);
            document.getElementById('btnAlerts').addEventListener('click', openAlertModal);
            document.getElementById('btnReports').addEventListener('click', openReportModal);
            document.getElementById('btnTogglePaths').addEventListener('click', togglePaths);
            document.getElementById('btnClearPaths').addEventListener('click', clearPaths);
            document.getElementById('btnExport').addEventListener('click', openExportModal);
            document.getElementById('btnRefresh').addEventListener('click', refreshData);
            document.getElementById('btnConnectBT').addEventListener('click', connectBluetooth);
            document.getElementById('btnCancelBT').addEventListener('click', () => document.getElementById('bluetoothModal').classList.remove('active'));
            document.getElementById('btnSaveAlerts').addEventListener('click', saveAlertConfig);
            document.getElementById('btnCancelAlerts').addEventListener('click', () => document.getElementById('alertModal').classList.remove('active'));
            document.getElementById('btnExportCSV').addEventListener('click', () => exportData('csv'));
            document.getElementById('btnExportJSON').addEventListener('click', () => exportData('json'));
            document.getElementById('btnCancelExport').addEventListener('click', () => document.getElementById('exportModal').classList.remove('active'));

            // Debug panel
            document.getElementById('debugToggle').addEventListener('click', toggleDebugPanel);
            document.getElementById('debugClose').addEventListener('click', () => document.getElementById('debugPanel').classList.remove('active'));

            // Cargar configuraci√≥n de alertas
            loadAlertConfig();
        }

        // ========== DEBUG FUNCTIONS ==========
        function toggleDebugPanel() {
            document.getElementById('debugPanel').classList.toggle('active');
        }

        function debugLog(message, type = 'info') {
            const debugLogEl = document.getElementById('debugLog');
            if (!debugLogEl) {
                console.log(`[DEBUG] ${message}`);
                return;
            }

            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'debug-log-error' : type === 'warn' ? 'debug-log-warn' : 'debug-log-info';
            const logEntry = document.createElement('div');
            logEntry.className = className;
            logEntry.textContent = `[${timestamp}] ${message}`;
            debugLogEl.appendChild(logEntry);
            debugLogEl.scrollTop = debugLogEl.scrollHeight;

            // Mantener solo los √∫ltimos 50 mensajes
            while (debugLogEl.children.length > 50) {
                debugLogEl.removeChild(debugLogEl.firstChild);
            }
        }

        // ========== DATA FETCHING (Legacy/Fallback) ==========
        async function fetchNodes() {
            try {
                const response = await fetch(CONFIG.apiEndpoint);
                const data = await response.json();
                return data.data.nodes || [];
            } catch (error) {
                console.error('Error fetching nodes:', error);
                return [];
            }
        }

        async function refreshData() {
            const nodes = await fetchNodes();
            if (nodes.length > 0) processNewData(nodes);
        }

        function processNewData(nodes) {
            lastNodesData = nodes;
            updateMap(nodes);
            updateTelemetry(nodes);
            updateNodesList(nodes);
            logNodeData(nodes);
        }

        // ========== HELPERS ==========
        function getNodeColor(id) {
            let hash = 0;
            for (let i = 0; i < id.length; i++) hash = id.charCodeAt(i) + ((hash << 5) - hash);
            const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
            return '#' + '00000'.substring(0, 6 - c.length) + c;
        }

        function formatTime(timestamp) {
            if (!timestamp) return '--:--';
            return new Date(timestamp * 1000).toLocaleTimeString();
        }

        function formatDistance(meters) {
            if (meters < 1000) return `${Math.round(meters)} m`;
            return `${(meters / 1000).toFixed(2)} km`;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const œÜ1 = lat1 * Math.PI / 180, œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180, ŒîŒª = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // ========== MAP UPDATE ==========
        function updateMap(nodes) {
            const currentIds = nodes.map(n => n.id);
            Object.keys(markers).forEach(id => {
                if (!currentIds.includes(id)) {
                    map.removeLayer(markers[id]);
                    delete markers[id];
                }
            });

            nodes.forEach(node => {
                if (node.position && node.position.latitude && node.position.longitude) {
                    const isGSM = node.long_name && (node.long_name.includes('GSM') || node.long_name.includes('SMS'));
                    const nodeColor = getNodeColor(node.id);
                    const iconHtml = `<div class="custom-icon" style="background-color: ${nodeColor}; border: 2px solid white;">${isGSM ? '‚úâÔ∏è' : 'üìç'}</div>`;
                    const icon = L.divIcon({ html: iconHtml, className: '', iconSize: [36, 36], iconAnchor: [18, 36], popupAnchor: [0, -36] });

                    if (markers[node.id]) {
                        markers[node.id].setLatLng([node.position.latitude, node.position.longitude]);
                        markers[node.id].setIcon(icon);
                    } else {
                        const marker = L.marker([node.position.latitude, node.position.longitude], { icon: icon }).addTo(map);
                        marker.bindPopup(`
                            <div style="color: #333;">
                                <h3 style="margin: 0 0 10px 0; color: ${nodeColor};">${node.long_name || node.short_name}</h3>
                                <p style="margin: 5px 0;"><strong>ID:</strong> ${node.id}</p>
                                <p style="margin: 5px 0;"><strong>Tipo:</strong> ${isGSM ? 'Reporte SMS' : 'Nodo Mesh'}</p>
                                <p style="margin: 5px 0;"><strong>√öltima vez:</strong> ${formatTime(node.last_heard)}</p>
                                <p style="margin: 5px 0;"><strong>Altitud:</strong> ${node.position.altitude}m</p>
                                ${node.snr ? `<p style="margin: 5px 0;"><strong>SNR:</strong> ${node.snr} dB</p>` : ''}
                                ${node.battery ? `<p style="margin: 5px 0;"><strong>Bater√≠a:</strong> ${node.battery}%</p>` : ''}
                            </div>
                        `);
                        markers[node.id] = marker;
                    }

                    // Actualizar traza de movimiento
                    updateNodePath(node);

                    // Verificar movimiento para alertas
                    checkNodeMovement(node);
                }
            });

            if (Object.keys(markers).length > 0 && !window.hasCentered) {
                map.fitBounds(L.featureGroup(Object.values(markers)).getBounds().pad(0.1));
                window.hasCentered = true;
            }
        }

        // ========== PATH TRACKING ==========
        function updateNodePath(node) {
            if (!node.position || !node.position.latitude || !node.position.longitude) return;

            const coords = [node.position.latitude, node.position.longitude];

            // Inicializar array si no existe
            if (!pathHistory[node.id]) {
                pathHistory[node.id] = [];
            }

            // Agregar nueva posici√≥n solo si es diferente a la √∫ltima
            const lastPos = pathHistory[node.id][pathHistory[node.id].length - 1];
            if (!lastPos || lastPos[0] !== coords[0] || lastPos[1] !== coords[1]) {
                pathHistory[node.id].push(coords);

                // Dibujar/actualizar polyline
                const nodeColor = getNodeColor(node.id);

                if (pathLines[node.id]) {
                    // Actualizar polyline existente
                    pathLines[node.id].setLatLngs(pathHistory[node.id]);
                } else {
                    // Crear nueva polyline
                    const polyline = L.polyline(pathHistory[node.id], {
                        color: nodeColor,
                        weight: 3,
                        opacity: 0.7,
                        smoothFactor: 1
                    }).addTo(map);

                    polyline.bindPopup(`
                        <div style="color: #333;">
                            <h4 style="margin: 0 0 8px 0; color: ${nodeColor};">Traza de ${node.long_name || node.short_name}</h4>
                            <p style="margin: 5px 0;"><strong>Puntos registrados:</strong> ${pathHistory[node.id].length}</p>
                        </div>
                    `);

                    pathLines[node.id] = polyline;
                }

                // Ocultar si el toggle est√° desactivado
                if (!showPaths && pathLines[node.id]) {
                    map.removeLayer(pathLines[node.id]);
                }

                debugLog(`üõ§Ô∏è Traza actualizada para ${node.long_name || node.id}: ${pathHistory[node.id].length} puntos`, 'info');
            }
        }

        function togglePaths() {
            showPaths = !showPaths;
            const btn = document.getElementById('btnTogglePaths');

            Object.values(pathLines).forEach(polyline => {
                if (showPaths) {
                    if (!map.hasLayer(polyline)) {
                        map.addLayer(polyline);
                    }
                } else {
                    if (map.hasLayer(polyline)) {
                        map.removeLayer(polyline);
                    }
                }
            });

            btn.style.opacity = showPaths ? '1' : '0.5';
            debugLog(`üõ§Ô∏è Trazas ${showPaths ? 'mostradas' : 'ocultadas'}`, 'info');
        }

        function clearPaths() {
            if (confirm('¬øLimpiar todas las trazas de movimiento?')) {
                // Remover polylines del mapa
                Object.values(pathLines).forEach(polyline => {
                    map.removeLayer(polyline);
                });

                // Limpiar datos
                pathHistory = {};
                pathLines = {};

                debugLog('üóëÔ∏è Trazas limpiadas', 'info');
                alert('Trazas limpiadas correctamente');
            }
        }

        // ========== ALERT SYSTEM ==========
        function openAlertModal() {
            // Cargar valores actuales
            document.getElementById('alertEnabled').checked = alertConfig.enabled;
            document.getElementById('idleTime').value = alertConfig.idleTimeMinutes;
            document.getElementById('soundEnabled').checked = alertConfig.soundEnabled;

            // Actualizar historial
            updateAlertHistoryDisplay();

            document.getElementById('alertModal').classList.add('active');
        }

        function saveAlertConfig() {
            alertConfig.enabled = document.getElementById('alertEnabled').checked;
            alertConfig.idleTimeMinutes = parseInt(document.getElementById('idleTime').value);
            alertConfig.soundEnabled = document.getElementById('soundEnabled').checked;

            // Guardar en localStorage
            localStorage.setItem('alertConfig', JSON.stringify(alertConfig));

            debugLog(`‚öôÔ∏è Configuraci√≥n de alertas guardada: ${alertConfig.idleTimeMinutes} min`, 'info');
            document.getElementById('alertModal').classList.remove('active');
        }

        function loadAlertConfig() {
            const saved = localStorage.getItem('alertConfig');
            if (saved) {
                try {
                    alertConfig = JSON.parse(saved);
                    debugLog('‚öôÔ∏è Configuraci√≥n de alertas cargada', 'info');
                } catch (e) {
                    debugLog('‚ö†Ô∏è Error cargando configuraci√≥n de alertas', 'warn');
                }
            }
        }

        function checkNodeMovement(node) {
            if (!alertConfig.enabled) return;
            if (!node.position || !node.position.latitude || !node.position.longitude) return;

            const now = Date.now();
            const coords = [node.position.latitude, node.position.longitude];

            // Inicializar estado del nodo si no existe
            if (!nodeStates[node.id]) {
                nodeStates[node.id] = {
                    lastPosition: coords,
                    lastMoveTime: now,
                    isIdle: false
                };
                return;
            }

            const state = nodeStates[node.id];
            const hasMoved = coords[0] !== state.lastPosition[0] || coords[1] !== state.lastPosition[1];

            if (hasMoved) {
                const idleTimeMs = alertConfig.idleTimeMinutes * 60 * 1000;
                const timeSinceLastMove = now - state.lastMoveTime;

                // Si estaba quieto y ahora se movi√≥, disparar alerta
                if (state.isIdle && timeSinceLastMove >= idleTimeMs) {
                    triggerMovementAlert(node, timeSinceLastMove);
                }

                // Actualizar estado
                state.lastPosition = coords;
                state.lastMoveTime = now;
                state.isIdle = false;
            } else {
                // Marcar como quieto si pas√≥ el tiempo configurado
                const idleTimeMs = alertConfig.idleTimeMinutes * 60 * 1000;
                if (now - state.lastMoveTime >= idleTimeMs) {
                    if (!state.isIdle) {
                        state.isIdle = true;
                        debugLog(`üò¥ ${node.long_name || node.id} est√° quieto (${alertConfig.idleTimeMinutes} min)`, 'info');
                    }
                }
            }
        }

        function triggerMovementAlert(node, idleTime) {
            const alert = {
                timestamp: Date.now(),
                nodeId: node.id,
                nodeName: node.long_name || node.short_name,
                idleTime: idleTime,
                position: node.position
            };

            alertHistory.unshift(alert); // Agregar al inicio

            // Limitar historial a 50 alertas
            if (alertHistory.length > 50) {
                alertHistory = alertHistory.slice(0, 50);
            }

            // Guardar en localStorage
            localStorage.setItem('alertHistory', JSON.stringify(alertHistory));

            // Mostrar notificaci√≥n visual
            showNotification(alert);

            // Reproducir sonido
            if (alertConfig.soundEnabled) {
                playAlertSound();
            }

            // Log
            debugLog(`üîî ALERTA: ${alert.nodeName} se movi√≥ despu√©s de ${Math.round(idleTime / 60000)} minutos`, 'warn');
        }

        function showNotification(alert) {
            const notification = document.createElement('div');
            notification.className = 'alert-notification';
            notification.innerHTML = `
                <div class="alert-icon">üîî</div>
                <div class="alert-content">
                    <strong>Movimiento Detectado</strong>
                    <p>${alert.nodeName} se movi√≥ despu√©s de ${Math.round(alert.idleTime / 60000)} minutos</p>
                </div>
                <button class="alert-close">‚úï</button>
            `;

            document.body.appendChild(notification);

            // Auto-cerrar despu√©s de 10 segundos
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 10000);

            // Cerrar manualmente
            notification.querySelector('.alert-close').addEventListener('click', () => {
                notification.remove();
            });
        }

        function playAlertSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.warn('No se pudo reproducir sonido de alerta:', e);
            }
        }

        function updateAlertHistoryDisplay() {
            const historyList = document.getElementById('alertHistoryList');

            // Cargar historial de localStorage si existe
            const saved = localStorage.getItem('alertHistory');
            if (saved) {
                try {
                    alertHistory = JSON.parse(saved);
                } catch (e) {
                    console.warn('Error cargando historial de alertas');
                }
            }

            if (alertHistory.length === 0) {
                historyList.innerHTML = '<p style="opacity: 0.6; font-size: 12px;">No hay alertas registradas</p>';
                return;
            }

            historyList.innerHTML = alertHistory.slice(0, 10).map(alert => `
                <div class="alert-item">
                    <div class="alert-item-time">${new Date(alert.timestamp).toLocaleString()}</div>
                    <div>${alert.nodeName} - ${Math.round(alert.idleTime / 60000)} min de quietud</div>
                </div>
            `).join('');
        }

        // ========== REPORT GENERATOR ==========
        async function openReportModal() {
            if (!db) {
                alert('Base de datos no disponible. Conecta el dispositivo y espera a recibir datos primero.');
                return;
            }

            // Obtener datos de IndexedDB
            const transaction = db.transaction(['nodeHistory'], 'readonly');
            const store = transaction.objectStore('nodeHistory');
            const request = store.getAll();

            request.onsuccess = () => {
                const data = request.result;

                if (data.length === 0) {
                    alert('No hay datos hist√≥ricos disponibles. Conecta el dispositivo y espera a recibir datos GPS.');
                    return;
                }

                // Generar informe
                generateReport(data);
            };

            request.onerror = () => {
                alert('Error al acceder a la base de datos');
            };
        }

        function generateReport(data) {
            // Calcular estad√≠sticas
            const stats = calculateReportStatistics(data);

            // Agrupar por nodo
            const nodeData = {};
            data.forEach(record => {
                if (!nodeData[record.nodeId]) {
                    nodeData[record.nodeId] = [];
                }
                nodeData[record.nodeId].push(record);
            });

            // Crear HTML del informe
            const reportHTML = createReportHTML(stats, nodeData);

            // Mostrar opciones de exportaci√≥n
            const exportChoice = confirm('Informe generado con √©xito.\n\n' +
                `Total de registros: ${data.length}\n` +
                `Per√≠odo: ${new Date(stats.startTime).toLocaleString()} - ${new Date(stats.endTime).toLocaleString()}\n` +
                `Distancia total: ${formatDistance(stats.totalDistance)}\n\n` +
                'Presiona OK para exportar a HTML, o Cancelar para ver resumen en consola');

            if (exportChoice) {
                downloadFile(reportHTML, `informe-rastreador-${Date.now()}.html`, 'text/html');
                debugLog('üìä Informe exportado a HTML', 'info');
            } else {
                console.log('=== RESUMEN DEL INFORME ===');
                console.log('Total de registros:', data.length);
                console.log('Per√≠odo:', new Date(stats.startTime).toLocaleString(), '-', new Date(stats.endTime).toLocaleString());
                console.log('Distancia total:', formatDistance(stats.totalDistance));
                console.log('Bater√≠a promedio:', Math.round(stats.avgBattery) + '%');
                console.log('SNR promedio:', stats.avgSNR.toFixed(1) + ' dB');
                console.log('Nodos √∫nicos:', Object.keys(nodeData).length);
                console.log('Datos completos disponibles en la variable:', data);
                debugLog('üìä Resumen del informe mostrado en consola', 'info');
            }
        }

        function calculateReportStatistics(data) {
            let totalDistance = 0;
            let batterySum = 0;
            let batteryCount = 0;
            let snrSum = 0;
            let snrCount = 0;

            // Ordenar por timestamp
            data.sort((a, b) => a.timestamp - b.timestamp);

            for (let i = 1; i < data.length; i++) {
                const prev = data[i - 1];
                const curr = data[i];

                if (prev.position && curr.position && prev.position.latitude && curr.position.latitude) {
                    const dist = calculateDistance(
                        prev.position.latitude,
                        prev.position.longitude,
                        curr.position.latitude,
                        curr.position.longitude
                    );
                    totalDistance += dist;
                }

                if (curr.battery) {
                    batterySum += curr.battery;
                    batteryCount++;
                }

                if (curr.snr) {
                    snrSum += curr.snr;
                    snrCount++;
                }
            }

            return {
                totalDistance,
                totalPoints: data.length,
                avgBattery: batteryCount > 0 ? batterySum / batteryCount : 0,
                avgSNR: snrCount > 0 ? snrSum / snrCount : 0,
                startTime: data[0].timestamp,
                endTime: data[data.length - 1].timestamp
            };
        }

        function createReportHTML(stats, nodeData) {
            const nodeNames = Object.keys(nodeData);

            let tableRows = '';
            Object.entries(nodeData).forEach(([nodeId, records]) => {
                records.forEach(record => {
                    tableRows += `
                        <tr>
                            <td>${new Date(record.timestamp).toLocaleString()}</td>
                            <td>${record.name || nodeId}</td>
                            <td>${record.position?.latitude?.toFixed(6) || 'N/A'}</td>
                            <td>${record.position?.longitude?.toFixed(6) || 'N/A'}</td>
                            <td>${record.position?.altitude || 'N/A'}</td>
                            <td>${record.snr || 'N/A'}</td>
                            <td>${record.battery || 'N/A'}</td>
                        </tr>
                    `;
                });
            });

            return `
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Informe Rastreador GPS H√≠brido</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 30px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 8px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: 700;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-size: 13px;
        }
        td {
            border: 1px solid #e0e0e0;
            padding: 10px;
            font-size: 12px;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
            text-align: center;
            color: #999;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Informe de Rastreador GPS H√≠brido</h1>
        <div class="subtitle">
            Per√≠odo: ${new Date(stats.startTime).toLocaleString()} - ${new Date(stats.endTime).toLocaleString()}
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Distancia Total</div>
                <div class="stat-value">${formatDistance(stats.totalDistance)}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Puntos Registrados</div>
                <div class="stat-value">${stats.totalPoints}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Bater√≠a Promedio</div>
                <div class="stat-value">${Math.round(stats.avgBattery)}%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">SNR Promedio</div>
                <div class="stat-value">${stats.avgSNR.toFixed(1)} dB</div>
            </div>
        </div>
        
        <h2 style="margin-top: 30px; margin-bottom: 15px; color: #333;">Telemetr√≠a Detallada</h2>
        <table>
            <thead>
                <tr>
                    <th>Fecha/Hora</th>
                    <th>Nodo</th>
                    <th>Latitud</th>
                    <th>Longitud</th>
                    <th>Altitud (m)</th>
                    <th>SNR (dB)</th>
                    <th>Bater√≠a (%)</th>
                </tr>
            </thead>
            <tbody>
                ${tableRows}
            </tbody>
        </table>
        
        <div class="footer">
            Generado por Rastreador GPS H√≠brido LoRa/GSM - ${new Date().toLocaleString()}<br>
            Proyecto Final de Ingenier√≠a Electr√≥nica
        </div>
    </div>
</body>
</html>
            `;
        }

        // ========== TELEMETRY UPDATE ==========
        function updateTelemetry(nodes) {
            if (nodes.length === 0) return;
            const primaryNode = nodes[0];
            const isGSM = primaryNode.long_name && primaryNode.long_name.includes('GSM');

            document.getElementById('signalType').textContent = isGSM ? 'GSM' : 'LoRa';
            document.getElementById('signalStrength').textContent = primaryNode.snr ? `${primaryNode.snr} dBm` : '-- dBm';
            if (primaryNode.battery) document.getElementById('batteryLevel').textContent = `${primaryNode.battery}%`;
            if (userLocation && primaryNode.position) {
                const distance = calculateDistance(userLocation.latitude, userLocation.longitude, primaryNode.position.latitude, primaryNode.position.longitude);
                document.getElementById('distance').textContent = formatDistance(distance);
            }
            document.getElementById('telemetrySignal').classList.toggle('gsm', isGSM);
        }

        // ========== NODES LIST UPDATE ==========
        function updateNodesList(nodes) {
            const nodesList = document.getElementById('nodesList');
            const nodeCount = document.getElementById('nodeCount');
            nodeCount.textContent = nodes.length;
            nodesList.innerHTML = '';

            if (nodes.length === 0) {
                nodesList.innerHTML = '<div class="loading">No hay nodos disponibles</div>';
                return;
            }

            console.log(`üìä Procesando ${nodes.length} nodos:`);

            nodes.forEach(node => {
                const isGSM = node.long_name && (node.long_name.includes('GSM') || node.long_name.includes('SMS'));
                const nodeColor = getNodeColor(node.id);

                console.log(`  - Nodo: ${node.long_name || node.short_name || node.id}`);
                console.log(`    ID: ${node.id}`);
                console.log(`    long_name: "${node.long_name}"`);
                console.log(`    isGSM: ${isGSM}`);

                const card = document.createElement('div');
                card.className = `node-card ${isGSM ? 'gsm' : ''}`;
                card.style.borderLeftColor = nodeColor;
                card.innerHTML = `
                    <div class="node-header">
                        <div class="node-name">
                            <span class="status-indicator" style="background-color: ${nodeColor};"></span>
                            ${node.long_name || node.short_name || 'Unknown'}
                        </div>
                        <div class="node-badge ${isGSM ? 'gsm' : ''}">${isGSM ? 'SMS/GSM' : 'LoRa'}</div>
                    </div>
                    <div class="node-info">
                        <div><strong>ID:</strong> ${node.id}</div>
                        <div><strong>√öltima conexi√≥n:</strong> ${formatTime(node.last_heard)}</div>
                        ${node.position && node.position.latitude ? `
                            <div><strong>Lat:</strong> ${node.position.latitude.toFixed(6)}</div>
                            <div><strong>Lon:</strong> ${node.position.longitude.toFixed(6)}</div>
                            <div><strong>Alt:</strong> ${node.position.altitude}m</div>
                        ` : '<div style="opacity: 0.6;">Sin posici√≥n GPS</div>'}
                        ${node.snr ? `<div><strong>SNR:</strong> ${node.snr} dB</div>` : ''}
                        ${node.battery ? `<div><strong>Bat:</strong> ${node.battery}%</div>` : ''}
                    </div>
                `;
                nodesList.appendChild(card);
            });
        }

        // ========== BLUETOOTH ==========
        function openBluetoothModal() {
            document.getElementById('bluetoothModal').classList.add('active');
        }

        async function connectBluetooth() {
            const statusEl = document.getElementById('bluetoothStatus');
            if (!navigator.bluetooth) {
                statusEl.textContent = 'Bluetooth no disponible en este navegador.';
                return;
            }

            try {
                statusEl.textContent = 'Buscando dispositivos...';
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'Meshtastic' }],
                    optionalServices: [MESH_SERVICE_UUID]
                });

                bluetoothDevice = device;
                statusEl.textContent = `Conectando a: ${device.name}...`;
                device.addEventListener('gattserverdisconnected', onDisconnected);

                const server = await device.gatt.connect();
                statusEl.textContent = 'Obteniendo servicio...';
                const service = await server.getPrimaryService(MESH_SERVICE_UUID);
                statusEl.textContent = 'Obteniendo caracter√≠stica...';
                const characteristic = await service.getCharacteristic(JSON_NODES_UUID);

                characteristic.addEventListener('characteristicvaluechanged', handleJsonData);
                await characteristic.startNotifications();

                statusEl.textContent = '¬°Conectado! Esperando datos...';
                console.log('‚úÖ Bluetooth conectado');
                setTimeout(() => document.getElementById('bluetoothModal').classList.remove('active'), 2000);
            } catch (error) {
                console.error('‚ùå Error Bluetooth:', error);
                statusEl.textContent = `Error: ${error.message}`;
            }
        }

        function onDisconnected(event) {
            console.log(`üì° Desconectado: ${event.target.name}`);
            alert('Dispositivo Bluetooth desconectado');
        }

        // Sistema de acumulaci√≥n de m√∫ltiples paquetes
        let accumulatedNodes = [];
        let lastPacketTime = 0;
        let packetCount = 0;
        const PACKET_TIMEOUT = 1000; // 1 segundo para esperar m√°s paquetes

        function handleJsonData(event) {
            const decoder = new TextDecoder('utf-8');
            const jsonString = decoder.decode(event.target.value);
            const now = Date.now();

            // Mostrar informaci√≥n detallada del JSON recibido
            debugLog(`üì• JSON RECIBIDO - Tama√±o: ${jsonString.length} bytes`, 'info');
            debugLog(`Contenido: "${jsonString.substring(0, 150)}..."`, 'info');
            console.log("üì• JSON recibido (length:", jsonString.length, "):", jsonString);

            // Si han pasado m√°s de PACKET_TIMEOUT desde el √∫ltimo paquete, procesar lo acumulado
            if (now - lastPacketTime > PACKET_TIMEOUT && accumulatedNodes.length > 0) {
                debugLog(`‚è∞ Timeout alcanzado, procesando ${accumulatedNodes.length} nodos acumulados`, 'warn');
                processNewData(accumulatedNodes);
                accumulatedNodes = [];
                packetCount = 0;
            }
            lastPacketTime = now;

            try {
                const cleanJson = jsonString.replace(/\0/g, '').trim();

                // Intentar parsear como JSON completo
                const data = JSON.parse(cleanJson);

                debugLog('‚úÖ JSON PARSEADO correctamente', 'info');
                debugLog('Claves encontradas: ' + Object.keys(data).join(', '), 'info');
                console.log('‚úÖ Parseado:', data);

                let nodes = null;

                // Detectar estructura del JSON
                if (data.data && data.data.nodes) {
                    nodes = data.data.nodes;
                    packetCount++;
                    debugLog(`üì¶ Paquete ${packetCount}: Encontrados ${nodes.length} nodos en data.data.nodes`, 'info');
                    console.log('üìç Encontrados', nodes.length, 'nodos en data.data.nodes');
                } else if (data.nodes) {
                    nodes = data.nodes;
                    packetCount++;
                    debugLog(`üì¶ Paquete ${packetCount}: Encontrados ${nodes.length} nodos en data.nodes`, 'info');
                    console.log('üìç Encontrados', nodes.length, 'nodos en data.nodes');
                } else if (Array.isArray(data)) {
                    // Puede ser un array directo de nodos
                    nodes = data;
                    packetCount++;
                    debugLog(`üì¶ Paquete ${packetCount}: Array directo con ${nodes.length} nodos`, 'info');
                } else if (data.id && data.long_name) {
                    // Es un nodo individual (probablemente el SMS)
                    nodes = [data];
                    packetCount++;
                    debugLog(`üì¶ Paquete ${packetCount}: Nodo individual detectado`, 'info');
                } else {
                    debugLog('‚ö†Ô∏è Estructura desconocida. Claves: ' + Object.keys(data).join(', '), 'warn');
                    console.warn('‚ö†Ô∏è Estructura desconocida. Claves:', Object.keys(data));
                    return;
                }

                // Acumular nodos
                nodes.forEach(node => {
                    // Crear una clave √∫nica combinando ID y nombre
                    // Esto permite que nodos SMS y LoRa con el mismo ID base coexistan
                    const nodeKey = `${node.id}_${node.long_name || node.short_name || ''}`;

                    // Verificar si el nodo ya existe (por clave compuesta)
                    const existingIndex = accumulatedNodes.findIndex(n => {
                        const existingKey = `${n.id}_${n.long_name || n.short_name || ''}`;
                        return existingKey === nodeKey;
                    });

                    if (existingIndex >= 0) {
                        // Actualizar nodo existente (el m√°s reciente tiene prioridad)
                        accumulatedNodes[existingIndex] = node;
                        debugLog(`  üîÑ Nodo actualizado: ${node.long_name || node.id}`, 'info');
                    } else {
                        // Agregar nuevo nodo
                        accumulatedNodes.push(node);
                        const isGSM = node.long_name && (node.long_name.includes('GSM') || node.long_name.includes('SMS'));
                        debugLog(`  ‚ûï Nodo agregado: ${node.long_name || node.id} [${isGSM ? 'SMS/GSM' : 'LoRa'}]`, 'info');
                    }
                });

                debugLog(`üìä Total acumulado: ${accumulatedNodes.length} nodos √∫nicos`, 'info');

                // Programar procesamiento despu√©s de un breve delay para esperar m√°s paquetes
                clearTimeout(window.processNodesTimeout);
                window.processNodesTimeout = setTimeout(() => {
                    if (accumulatedNodes.length > 0) {
                        debugLog(`‚úÖ Procesando ${accumulatedNodes.length} nodos acumulados`, 'info');

                        // Log detallado de cada nodo antes de procesar
                        accumulatedNodes.forEach((node, index) => {
                            const isGSM = node.long_name && (node.long_name.includes('GSM') || node.long_name.includes('SMS'));
                            debugLog(`  Nodo ${index + 1}: ${node.long_name || node.id} [${isGSM ? 'SMS/GSM' : 'LoRa'}]`, 'info');
                            if (node.position && node.position.latitude) {
                                debugLog(`    Pos: ${node.position.latitude}, ${node.position.longitude}`, 'info');
                            } else {
                                debugLog('    ‚ö†Ô∏è Sin posici√≥n GPS v√°lida', 'warn');
                            }
                        });

                        processNewData(accumulatedNodes);
                        accumulatedNodes = [];
                        packetCount = 0;
                    }
                }, 500); // Esperar 500ms por si llega otro paquete

            } catch (e) {
                debugLog('‚ùå ERROR parsing JSON: ' + e.message, 'error');
                debugLog('JSON que caus√≥ error: ' + jsonString.substring(0, 100) + '...', 'error');
                console.error('‚ùå Error parsing:', e, jsonString);
            }
        }

        // ========== DATA LOGGER (IndexedDB) ==========
        function initDataLogger() {
            const request = indexedDB.open('RastreadorDB', 2);
            request.onerror = () => console.error('Error IndexedDB');
            request.onsuccess = (e) => { db = e.target.result; };
            request.onupgradeneeded = (e) => {
                const database = e.target.result;
                if (!database.objectStoreNames.contains('nodeHistory')) {
                    const store = database.createObjectStore('nodeHistory', { keyPath: 'id', autoIncrement: true });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                    store.createIndex('nodeId', 'nodeId', { unique: false });
                }
            };
        }

        function logNodeData(nodes) {
            if (!db) return;
            const transaction = db.transaction(['nodeHistory'], 'readwrite');
            const store = transaction.objectStore('nodeHistory');
            nodes.forEach(node => {
                store.add({
                    timestamp: Date.now(),
                    nodeId: node.id,
                    name: node.long_name || node.short_name,
                    position: node.position,
                    snr: node.snr,
                    battery: node.battery,
                    last_heard: node.last_heard
                });
            });
        }

        // ========== EXPORT DATA ==========
        function openExportModal() {
            document.getElementById('exportModal').classList.add('active');
        }

        async function exportData(format) {
            if (!db) {
                alert('Base de datos no disponible. Exportando datos actuales.');
                const data = lastNodesData.map(n => ({
                    timestamp: Date.now(),
                    nodeId: n.id,
                    name: n.long_name,
                    position: n.position,
                    snr: n.snr,
                    battery: n.battery
                }));
                format === 'csv' ? exportToCSV(data) : exportToJSON(data);
                return;
            }

            const transaction = db.transaction(['nodeHistory'], 'readonly');
            const store = transaction.objectStore('nodeHistory');
            const request = store.getAll();

            request.onsuccess = () => {
                const data = request.result;
                if (data.length === 0) {
                    alert('No hay historial guardado.');
                    return;
                }
                format === 'csv' ? exportToCSV(data) : exportToJSON(data);
                document.getElementById('exportModal').classList.remove('active');
            };
        }

        function exportToCSV(data) {
            const headers = ['Timestamp', 'Fecha', 'ID Nodo', 'Nombre', 'Latitud', 'Longitud', 'Altitud', 'SNR', 'Bater√≠a'];
            const rows = data.map(r => {
                const date = new Date(r.timestamp);
                return [
                    r.timestamp,
                    date.toLocaleString('es-AR'),
                    r.nodeId,
                    r.name || 'Unknown',
                    r.position?.latitude || '',
                    r.position?.longitude || '',
                    r.position?.altitude || '',
                    r.snr || '',
                    r.battery || ''
                ];
            });
            const csv = [headers, ...rows].map(row => row.join(',')).join('\n');
            downloadFile(csv, 'rastreador-historial.csv', 'text/csv');
        }

        function exportToJSON(data) {
            downloadFile(JSON.stringify(data, null, 2), 'rastreador-historial.json', 'application/json');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ========== GEOLOCATION ==========
        function requestUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(
                    (position) => { userLocation = { latitude: position.coords.latitude, longitude: position.coords.longitude }; },
                    (error) => { console.log('Geolocalizaci√≥n no disponible:', error); }
                );
            }
        }
    </script>
</body>

</html>